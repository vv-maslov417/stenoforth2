ДЛЯ БЫСТРОГО СОЗДАНИЯ ОПРЕДЕЛЕНИЙ СЛОВ В КРАТКОЙ ФОРМЕ

Набор символов контекста слов одинарной разрядности с фиксированной точкой
и символы выбора контекстов слов и статических переменных всех типов

символ  слово    символ  слово     символ  слово
a       abs      A       again     !       !
b       c@       B       begin     "       Контекст слов двойной разрядности с фиксированной точкой
c       emit     C       case      #       <>
d       dup      D       ?do       $       Контекст статических локальных переменных разрядности 64 с плавающей точкой
e       else     E       endcase   %       mod
f       endof    F       fill      &       and
g       rnd      G       ado       '       Не используется
h       here     H       within    (       Не используется
i       1+       I       i         )       Не используется
j       1-       J       j         *       *
k       key      K       compare   +       +
l       lshift   L       loop      ,       Контекст статических локальных переменных с плавающей точкой
m       min      M       max       -       -
n       negate   N       +loop     .       Не используется
o       of       O       erase     /       /
p       depth    P       randomize :       Контекст статических многопоточных локальных переменных одинарной разрядности с фиксированной точкой
q       sqrt     Q       leave     ;       Контекст статических многопоточных локальных переменных с плавающей точкой
r       rshift   R       repeat    <       <
s       i+       S       search    =       =
t       then     T       true      >       >
u       evaluate U       until     ?       if
v       резерв   V       move      @       @
w       c!       W       while     [       Контекст слов одинарной разрядности с фиксированной точкой
x       drop     X       execute   \       Контекст локальных переменных с фиксированной точкой одинарной разрядности
y       0        Y       1         ]       Не используется
z       0<>      Z       0=        ^       xor
                                   _       allot
                                   `       Не используется
                                   {       Контекст слов с плавающей точкой
                                   |       or
                                   }       Не используется
                                   ~       invert
                                   :       ->    Используется как TO для стат. переменных всех типов в контекстах слов всех типов
                                   !d      Контекст статических локальных переменных двойной разрядности с фиксированной точкой

( n1 n2 - n1*n1+n2*n2 ) - сумма квадратов двух чисел с фикс. точкой
: primer1 \12 [11*22*+ ;  \ вместо \12 можно написать |2 - актуально когда много переменных -> |8 вместо \12345678

\ - переход в контекст локальных переменных одинарной разрядности с фикс. точкой
1 2 - лок. переменные n1 n2 ( максимальное количество таких переменных - 9 )
пробел - переход в базовый контекст FORTH
[ - переход в контекст слов одинарной разрядности с фиксированной точкой

( n1 n2 - n1*n1+n2*n2 ) - сумма квадратов двух чисел с плав. точкой
: primer2 $12 {11*22*+ ; \ вместо {12 можно написать |$2 - актуально когда много переменных -> |$8 вместо $12345678

$ - переход в контекст локальных переменных разрядности 64 с плав. точкой
1 2 - лок. переменные n1 n2 ( максимальное количество таких переменных - 9 )
пробел - переход в базовый контекст FORTH
{ - переход в контекст слов разрядности 64 с плавающей точкой

Набор символов контекста слов двойной разрядности с фиксированной точкой
слов вывода и часто используемых слов

символ  слово    символ  слово           символ  слово
a       dabs     A       allocate        !       2!
b       w@       B       .0b             "       резерв
c       emit     C       резерв          #       d<>
d       2dup     D       ?do             $       резерв
e       else     E       Не используется %       dmod
f       f>d      F       free throw      &       dand
g       резерв   G       ado             '       Не используется
h       here     H       .0h             (       Не используется
i       1+!      I       I               )       Не используется
j       1-!      J       J               *       d*
k       резерв   K       резерв          +       d+
l       dlshift  L       loop            ,       Не используется
m       dmin     M       dmax            -       d-
n       dnegate  N       +loop           .       d.
o       резерв   O       .0              /       d/
p       depth    P       NextWord        :       ->
q       sqrt     Q       резерв          ;       exit
r       drshift  R       resize throw    <       d<
s       space    S       резерв          =       d=
t       then     T       type            >       d>
u       evaluate U       резерв          ?       if
v       резерв   V       move            @       2@
w       w!       W       резерв          [       Не используется
x       2drop    X       резерв          \       cr
y       0.       Y       1.              ]       Не используется
z       d0<>     Z       d0=             ^       dxor
                                         _       .bl
                                         `       Не используется
                                         {       Не используется
                                         |       dor
                                         }       Не используется
                                         ~       dinvert

\ n1 n2 - n1*n1+n2*n2  - сумма квадратов чисел с фикс. точкой дв. разр-ти
: primer3 !d12 "11*22*+ ; \ вместо !d12 можно написать |d2 - актуально когда много переменных -> |d8 вместо !d12345678

!d - переход в контекст локальных переменных двойной разрядности с фикс. точкой
1 2 - лок. переменные n1 n2 ( максимальное количество таких переменных - 9 )
пробел - переход в базовый контекст FORTH
" - переход в контекст слов двойной разрядности с фиксированной точкой


Набор символов контекста слов для работы с данными с плавающей точкой разрядности 64.
Слова структур управления продублированы в этом контексте чтобы не переключать контекст
при их использования.

символ  слово    символ  слово    символ  слово
a       FABS     A       AGAIN    @       F@
b       FLOG2    B       BEGIN    !       F!
c       FCOS     C       CASE     +       F+
d       FDUP     D       ?DO      -       F-
e       ELSE     E       ENDCASE  *       F*
f       DS>F     F       D>F      /       F/
g       FLOG     G       aDO      =       F=
h       HERE                      #       F<>
i       F1+      I       I        ?       IF
j       F1-      J       J        <       F<
k       FACOS    K                >       F>
l       FLN      L       LOOP     ~       F~
m       FMIN     M       FMAX     ^       F**
n       FNEGATE  N       +LOOP    .       F.
o       FDEPTH   O       FDEPTH   :       ->
p       F**2     P       FPI      ;       EXIT
q       FSQRT    Q       LEAVE
r       FASIN    R       REPEAT
s       FSIN     S       F>DS
t       THEN     T       FTAN
u       FATAN    U       UNTIL

                 W       WHILE
x       FDROP    X       EXP
y       0        Y       1
z       F0<>     Z       F0=

Пример: Площадь треугольника по формуле Герона:
: S3 \ a b c -- S
  0e |$4 {12+3+ 2e {/:441-42-*43-*4*q. ;
на стеке длины сторон треугольника - 3 числа с плав. точкой
заводим 4 локальных переменных с плав. точкой
первые 3 это стороны a b c, а чевертая лок. переменная под значение
полупериметра треугольника изначально инициализируется нулем.
Вычисляем полупериметр и заносим его значение в лок. переменную 4 {12+3+ 2e {/:4
Затем перемножаем разности полупериметра и каждой из сторон и сам полупериметр
41-42-*43-*4*, а затем из полученного значения извлекаем квадратный корень
и распечатываем q. - это и есть площадь треугольника.

РАСШИРЕНИЕ СИНТАКСИСА

1. Определение макросов
m: name .... ;

здесь:
name - имя макроса
.... - форт-текст, который может включать и имена ранее определенных макросов.

2. Определение локальных макросов

: name
  ....
  name1[ .... ]
  ....
  name2[ .... name1 .... ]
  name2
  ....
  name1
  ....
;
здесь:
name1 - имя локального макроса
.... - форт-текст, который может включать и имена как ранее определенных макросов так и
как ранее, так и позднее определенных локальных макросов.
Имена локальных макросов видны только внутри определения, в котором они определены.

3. Определение локальных слов

: name
  ....
  name1( .... )
  ....
  name2( .... name1 .... )
  name2
  ....
  name1
  ....
;
здесь:
name1, name2 - имена локальных слов
.... - форт-текст, который может включать и имена ранее определенных макросов и слов
так и ранее определенных локальных макросов и слов.
Имена локальных слов видны только внутри определения, в котором они определены.

Для получения исполнительного адреса локального слова внутри определения:
: name
 ....
 l' name1 \ -- xt
;
Этот адрес может быть передан через стек данных после исполнения слова name
для исполнения внутреннего слова name1 c помощью execute.
ДЛЯ ЛОКАЛЬНЫХ МАКРОСОВ ТАКОЙ СПОСОБ ИСПОЛЬЗОВАТЬ НЕЛЬЗЯ.

4. Определение именованных строк

t: name .... ;
здесь:
name - имя строки
.... - символы строки

Особенностью таких строк является минимизация количества пробелов в их непрерывных последовательностях
в строке и удаление символов перевода строк, например определение строки с именем string1

t: string1 12345   89798
jkbbhn     uyggu
654
;

string1 type ( 12345 89798 jkbbhn uyggu 654 )

5. Определение локальных именованных строк
: name
  ....
  name1" ....
  ....
  .... "
  ....
  name1
  ....
;
здесь:
name1 - имя локальной строки
.... - символы строки
После символа " и перед символом " должен быть пробел
Локальные строки ведут себя аналогично именованным строкам.

6. Создание группы слов глобальной видимости(словарь Forth) с доступом каждого последующего глобального слова в группе
к локальным переменным и словам всех предыдущих определений глобальных слов группы.

: name1 | v1\  v2$  v3: v4; |
  name2[ .... ]
  name3( .... )
  name4" .... "
........
;
+: name5 ... \ по слову +: в группу добавляются слова глобальной видимости 
   name6[ name2 name3 ...  5e -> v2 ... ]
   name7( 2 -> v1 ..  name4 ... )
........
;
+: name8
   name7 ..... 12,123 -> v4
....
;
: name9 .... ;
Формирование группы заканчиваеся по первому символу ':' без плюса

Пример: Арифметические операции над группой чисел

: IniGrAr
gt[ NextWord number? if drop ]
bo[ gt else 2drop exit then begin gt ]
eo[ else 2drop state @ if lit, then exit then again ]
;

+: (+ bo +  eo ; immediate
+: (- bo -  eo ; immediate
+: (* bo *  eo ; immediate
+: (/ bo /  eo ; immediate

: foo
(+ 56 44 -10 1 )
(- 56 44 -10 1 )
(* 20 3 -4 5 -6 )
(/ 240 2 3 -2 5 )
;

foo .s

лог
91 21 7200 4294967292(-4)

7. Литеральные имена
Лексемы, которыми обозначают имена слов в Forth обычно являются только метками(идентификаторами),
то есть при формировании определенного кода его можно связать с произвольным именем.
Литеральное имя(лексема) содержит информацию, по которой его код будет сформирован и/или исполнен, и по сути является
входом в программу формирования и/или исполнения определенного кода. Как пример литеральных имен в Forth можно
привести лексемы чисел различного формата(десятичные, шестнадцатиричные)
Примеры:
лексемы вида n\abc..z
где  n цифра(от 1 до 5 включительно) указывает, что лексема будет работать с верхними n числами с фикс. точкой на стеке данных,
нумерация которых будет, например, при n = 5   1 2 3 4 5(5 - на вершине стека), а  a b c .. z цифры от 1 до n (максимум 16 цифр)
и в результате исполнения такого литерального имени на стеке будет определенный таким именем набор чисел из исходного набора чисел.
Например литеральное имя 5\543211223341 после его исполнения изменит стек с 1 2 3 4 5 до 5 4 3 2 1 1 2 2 3 3 4 1 
Нельзя использовать литеральные имена одинаковые с обычными именами в одном контексте поиска, так как поиск имен закончится на обычном имени, 
а литеральное имя не будет найдено. 
Трансляция литеральных имен состоит из 3-х этапов. 1 этап - определение точки входа в конкретную программу формирования кода по имени литерала.
2 этап - генерация конкретного кода для имени литерала. 3 этап - исполнение кода, состоящее либо в компиляции кода, либо дополнительно еще и 
в исполнении скомпилированного кода. При этом после исполнения скомпилированный код может быть и удален, например, в ситуации когда код литерала
не входит в код какого-либо слова с обычным именем-идентификатором. 

пример: реализация слов drop3, drop4 ... drop9

rec:  dig[ pos>char '0' - ]                        \ определение того, что лексема имеет вид drop3, drop4 ... drop9
      u 5 = 5 dig 3 10 within and                  \ здесь a и u, встроенные в конструкцию rec: ... gen: ... ;  локальные переменные 
                                                   \ содержащие адрес и длину лексемы литерального имени в буфере входного потока 
      a u 1- s" drop" compare 0= and
gen:  dropn[ g| 5 dig dup 1- 4 * t=c 4 * pa |g ]   \ если лексема та что надо, формируется код для режимов компиляции и интерпретации
                                                   \ в режиме интерпретации код соответствующей лексемы удаляется из памяти программ
      state @ if   dropn                           \ после его исполнения( можно и не удалять, если зачем-то надо)
              else here >r dropn ret, r@ execute r> dp !
              then ;
1 2 3 4 5 6 7 8 drop6 ( 1 2 )
: foo 1 2 3 4 5 6 7 drop4 ; foo ( 1 2 3 )

Подробности реализации конструкции rec: ... gen: ... ; в файле closure.f
